import base64
import os
import sys
from PyQt5.QtGui import QFontDatabase, QDesktopServices
from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEnginePage
from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QToolBar, QLineEdit, QStatusBar, QMessageBox, \
    QListWidget, QDialog, QVBoxLayout, QListWidgetItem, QAbstractItemView, QPushButton, QLabel, QDesktopWidget

from PyQt5.QtWidgets import QFileDialog, QMessageBox
from PyQt5.QtCore import QUrl, QTimer, QEventLoop, Qt
from pymongo import MongoClient
from PIL import Image
import fitz  # PyMuPDF
from PyQt5.QtWidgets import QProgressDialog

from PyQt5.QtWidgets import QDialog, QProgressBar, QLabel, QVBoxLayout, QSizePolicy, QPushButton
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer
from docx2txt import process


class LoadingDialog(QDialog):
    def __init__(self, parent=None):
        super(LoadingDialog, self).__init__(parent)
        self.setWindowTitle("Collecting data")
        self.setGeometry(0, 0, 300, 100)
        self.setWindowFlags(Qt.Window | Qt.CustomizeWindowHint | Qt.WindowTitleHint | Qt.WindowStaysOnTopHint)
        self.center()

        self.progress_label = QLabel("Logging in...", self)
        self.progress_bar = QProgressBar(self)
        self.progress_bar.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.cancel_button = QPushButton("Cancel", self)
        self.cancel_button.clicked.connect(self.close)

        layout = QVBoxLayout(self)
        layout.addWidget(self.progress_label)
        layout.addWidget(self.progress_bar)
        layout.addWidget(self.cancel_button)

        self.thread = None
        self.worker = None

    def center(self):
        frame_geometry = self.frameGeometry()
        desktop_center = QDesktopWidget().availableGeometry().center()
        frame_geometry.moveCenter(desktop_center)
        self.move(frame_geometry.topLeft())

    def set_progress(self, value):
        self.progress_bar.setValue(value)

    def set_progress_label(self, text):
        self.progress_label.setText(text)

    def closeEvent(self, event):
        if self.thread and self.thread.isRunning():
            self.worker.stop()
            self.thread.quit()
            self.thread.wait()
        event.accept()


class Worker(QThread):
    progress_changed = pyqtSignal(int)
    label_changed = pyqtSignal(str)

    def __init__(self):
        super(Worker, self).__init__()
        self.running = True

    def run(self):
        # Simulating a time-consuming task
        for i in range(101):
            if not self.running:
                break
            self.progress_changed.emit(i)
            self.label_changed.emit(f"Logging in... {i}%")
            self.msleep(20)
        self.finished.emit()

    def stop(self):
        self.running = False


class RegistrationDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("User Registration")
        layout = QVBoxLayout()
        self.username_label = QLabel("Username:")
        self.username_input = QLineEdit()
        self.email_label = QLabel("Email:")
        self.email_input = QLineEdit()
        self.register_button = QPushButton("Register")
        self.register_button.clicked.connect(self.register_user)
        self.login_button = QPushButton("Login")
        self.login_button.clicked.connect(self.login_user)
        layout.addWidget(self.username_label)
        layout.addWidget(self.username_input)
        layout.addWidget(self.email_label)
        layout.addWidget(self.email_input)
        layout.addWidget(self.register_button)
        layout.addWidget(self.login_button)
        self.ID = None  # Initialize ID variable
        self.setLayout(layout)

    def register_user(self):
        username = self.username_input.text()
        email = self.email_input.text()

        if not (username and email):
            QMessageBox.warning(self, "Registration Error", "Both username and email are required.")
            return

        # Connect to MongoDB
        mongo_url = "mongodb+srv://otmanagement:otmanagement@otmanagement.prask0n.mongodb.net/"
        client = MongoClient(mongo_url)
        database = client['your_database_name']  # Replace 'your_database_name' with your actual database name
        collection = database['users']

        # Check if username or email already exists
        existing_user = collection.find_one({"$or": [{"username": username}, {"email": email}]})

        if existing_user:
            QMessageBox.warning(self, "Registration Error", "Username or email already exists.")
            client.close()
            return

        # Create a new document with an autogenerated ID
        user_data = {
            "username": username,
            "email": email
        }
        result = collection.insert_one(user_data)
        self.ID = str(result.inserted_id)
        # Print the autogenerated ID
        print(f"User registered - Username: {username}, Email: {email}, ID: {result.inserted_id}")

        # Close the MongoDB connection
        client.close()

        self.accept()

    def login_user(self):

        username = self.username_input.text()
        email = self.email_input.text()
        # self.show_loading_bar()

        progress_dialog = QProgressDialog("Please wait...", None, 0, 0, self)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Call your login function in a separate thread or process
        # For simplicity, let's simulate a delay using QEventLoop
        loop = QEventLoop()
        QTimer.singleShot(2000, loop.quit)
        loop.exec_()

        # Close the progress dialog

        if not (username and email):
            QMessageBox.warning(self, "Login Error", "Both username and email are required.")
            return

        # Connect to MongoDB
        mongo_url = "mongodb+srv://otmanagement:otmanagement@otmanagement.prask0n.mongodb.net/"
        client = MongoClient(mongo_url)
        database = client['your_database_name']  # Replace 'your_database_name' with your actual database name
        collection = database['users']

        # Check if the user exists
        existing_user = collection.find_one({"$or": [{"username": username}, {"email": email}]})
        progress_dialog.close()

        if existing_user:
            # Store the _id in the ID variable
            self.ID = str(existing_user['_id'])
            print(f"User registered - Username: {username}, Email: {email}, ID: {self.ID}")
            QMessageBox.information(self, "Login Successful", f"Login successful! User ID: {self.ID}")

            self.accept()
        else:
            QMessageBox.warning(self, "Login Error", "User not found. Please register first.")

        # Close the MongoDB connection
        client.close()

    def show_loading_bar(self):
        loading_dialog = LoadingDialog(self)
        loading_dialog.show()

        # Create a worker thread for the time-consuming task
        self.worker = Worker()
        self.worker.progress_changed.connect(loading_dialog.set_progress)
        self.worker.label_changed.connect(loading_dialog.set_progress_label)
        self.worker.finished.connect(loading_dialog.close)

        # Start the worker thread
        self.worker.start()


class WebBrowser(QMainWindow):
    def __init__(self):
        super().__init__()

        if not self.user_exists():
            registration_dialog = RegistrationDialog()
            if registration_dialog.exec_() != QDialog.Accepted:
                sys.exit()

        self.ID = registration_dialog.ID

        self.browser = QWebEngineView()
        self.browser.setUrl(QUrl("https://www.google.com"))
        self.setCentralWidget(self.browser)

        nav_toolbar = QToolBar("Navigation")
        self.addToolBar(nav_toolbar)

        back_btn = QAction("Back", self)
        back_btn.setStatusTip("Back to the previous page")
        back_btn.triggered.connect(self.browser.back)
        nav_toolbar.addAction(back_btn)

        forward_btn = QAction("Forward", self)
        forward_btn.setStatusTip("Forward to the next page")
        forward_btn.triggered.connect(self.browser.forward)
        nav_toolbar.addAction(forward_btn)

        reload_btn = QAction("Reload", self)
        reload_btn.setStatusTip("Reload page")
        reload_btn.triggered.connect(self.browser.reload)
        nav_toolbar.addAction(reload_btn)

        home_btn = QAction("Home", self)
        home_btn.setStatusTip("Go to the home page")
        home_btn.triggered.connect(self.navigate_home)
        nav_toolbar.addAction(home_btn)

        nav_toolbar.addSeparator()

        self.urlbar = QLineEdit()
        self.urlbar.returnPressed.connect(self.navigate_to_url)
        nav_toolbar.addWidget(self.urlbar)

        stop_btn = QAction("Stop", self)
        stop_btn.setStatusTip("Stop loading the current page")
        stop_btn.triggered.connect(self.browser.stop)
        nav_toolbar.addAction(stop_btn)

        view_downloads_btn = QAction("View Downloads", self)
        view_downloads_btn.setStatusTip("View downloaded files")
        view_downloads_btn.triggered.connect(self.view_downloads)
        nav_toolbar.addAction(view_downloads_btn)

        # Add a "View User Dashboard" button to the navigation toolbar
        view_dashboard_btn = QAction("View User Dashboard", self)
        view_dashboard_btn.setStatusTip("View user dashboard")
        view_dashboard_btn.triggered.connect(self.view_user_dashboard)
        nav_toolbar.addAction(view_dashboard_btn)

        # Create a list widget to display downloaded files
        self.downloads_list = QListWidget()
        self.downloads_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.downloads_list.itemDoubleClicked.connect(self.open_selected_download)

        self.browser.urlChanged.connect(self.update_urlbar)
        self.status = QStatusBar()
        self.setStatusBar(self.status)

        # Connect the loadFinished signal to show an alert when the page is loaded.
        self.browser.loadFinished.connect(self.page_loaded_alert)

        # Create a QWebEnginePage instance for handling downloads
        self.download_page = QWebEnginePage(self)
        self.download_page.profile().downloadRequested.connect(self.handle_download_request)

        # Connect to MongoDB
        mongo_url = "mongodb+srv://otmanagement:otmanagement@otmanagement.prask0n.mongodb.net/"
        client = MongoClient(mongo_url)
        self.database = client['your_database_name']  # Replace 'your_database_name' with your actual database name
        self.user_collection = self.database['users']

    def navigate_home(self):
        self.browser.setUrl(QUrl("https://www.google.com"))

    def get_user_info(self):
        user_data = self.user_collection.find_one({"user_id": self.ID})

        if user_data:
            return {"name": user_data.get("name", ""), "email": user_data.get("email", "")}
        else:
            return {"name": "", "email": ""}

    def view_user_dashboard(self):
        user_info_dialog = QDialog(self)
        user_info_dialog.setWindowTitle("User Dashboard")

        # Retrieve user information from MongoDB
        user_info = self.get_user_info()

        # Create labels to display user information
        user_name_label = QLabel(f"Name: {user_info['name']}")
        user_email_label = QLabel(f"Email: {user_info['email']}")

        layout = QVBoxLayout()
        layout.addWidget(user_name_label)
        layout.addWidget(user_email_label)

        user_info_dialog.setLayout(layout)
        user_info_dialog.exec_()

    def view_user_dashboard(self):
        user_info_dialog = QDialog(self)
        user_info_dialog.setWindowTitle("User Dashboard")

        # Retrieve user information from MongoDB
        user_info = self.get_user_info()

        # Create labels to display user information
        user_name_label = QLabel(f"Name: {user_info['name']}")
        user_email_label = QLabel(f"Email: {user_info['email']}")

        layout = QVBoxLayout()
        layout.addWidget(user_name_label)
        layout.addWidget(user_email_label)

        user_info_dialog.setLayout(layout)
        user_info_dialog.exec_()

    def user_exists(self):
        # You can check if a user exists by checking your storage method
        # In this example, we assume that if a user is registered, a file named "user.txt" exists.
        return os.path.exists("user.txt")

    # def page_loaded_alert(self, ok):
    #     current_url = self.browser.url().toString()
    #     if ok and current_url == "https://abc.com/":
    #         QMessageBox.information(self, "Page Loaded", "abc.com has finished loading.1")

    def navigate_to_url(self):
        url = self.urlbar.text()
        q = QUrl(url)
        if q.scheme() == "":
            q.setScheme("http")

        # Check if the loaded URL's host is "127.0.0.1" and port is 5000
        if q.host() == "127.0.0.1" and q.port() == 5000:
            # Show a confirmation dialog
            reply = QMessageBox.question(self, 'Confirmation', 'Do you want to load http://127.0.0.1:5000?', QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                key = "123456"

                # Construct the URL with the key
                url = f"http://127.0.0.1:5000/?key={key}"
                w = QUrl(url)
                self.browser.setUrl(w)
        else:
            self.browser.setUrl(q)

    def update_urlbar(self, q):
        self.urlbar.setText(q.toString())
        self.urlbar.setCursorPosition(0)

        # Check if the loaded URL's host is "127.0.0.1" and port is 5000
        if q.host() == "127.0.0.1" and q.port() == 5000:
            QMessageBox.information(self, "Page Loaded", "http://127.0.0.1:5000/ has finished loading.")

    def page_loaded_alert(self, ok):
        if ok:
            QMessageBox.information(self, "Page Loaded", f"The page has finished loading. User ID: {self.ID}")

    def view_downloads(self):
        self.show_loading_bar()

        dialog = QDialog(self)
        dialog.setWindowTitle("Downloads")

        layout = QVBoxLayout()
        layout.addWidget(self.downloads_list)
        dialog.setLayout(layout)
        print("Hello3")
        self.populate_downloads_list()

        dialog.exec_()

    def populate_downloads_list(self):
        self.downloads_list.clear()

        # Connect to MongoDB
        mongo_url = "mongodb+srv://otmanagement:otmanagement@otmanagement.prask0n.mongodb.net/"
        client = MongoClient(mongo_url)
        database = client['downloaded_fils']  # Replace 'your_database_name' with your actual database name
        collection = database['downloads']

        # Retrieve download information based on self.ID
        download_info = collection.find({"user_id": self.ID})

        # Add each download item to the list widget
        for info in download_info:
            file_path = info.get("file_path", "")
            if file_path:
                item = QListWidgetItem(file_path)
                self.downloads_list.addItem(item)

        # Close the MongoDB connection
        client.close()

    def open_selected_download(self):
        selected_item = self.downloads_list.currentItem()
        if selected_item:
            file_name = selected_item.text()
            storage_dir = 'storage'
            file_path = os.path.join(file_name)

            if os.path.exists(file_path):
                file_extension = file_name.split('.')[-1].lower()
                if file_extension == 'pdf':
                    self.open_pdf(file_path)
                elif file_extension in ['jpg', 'jpeg', 'png', 'gif']:
                    self.open_image(file_path)
                elif file_extension in ['doc', 'docx']:
                    self.open_word_in_browser(file_path)
                elif file_extension in ['xls', 'xlsx']:
                    self.open_excel_file(file_path)
                else:
                    QMessageBox.warning(self, "File Type Not Supported", f"Cannot open files of type: {file_extension}")
            else:
                QMessageBox.warning(self, "File does not exist", f"File does not exist: {file_path}")

    def get_file_extension(self, file_path):
        return os.path.splitext(file_path)[1][1:].lower()

    def open_word_document(self, file_path):
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
        except Exception as e:
            QMessageBox.warning(self, "Error Opening Word Document", f"Error opening Word document: {str(e)}")

    def open_excel_file(self, file_path):
        try:
            QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
        except Exception as e:
            QMessageBox.warning(self, "Error Opening Excel File", f"Error opening Excel file: {str(e)}")

    def open_pdf(self, file_path):
        # Open PDF files using PyMuPDF
        try:
            pdf_document = fitz.open(file_path)
            pdf_page = pdf_document.load_page(0)
            image = pdf_page.get_pixmap()
            image.save("temp_image.png", "png")
            pdf_document.close()

            # Open the temporary image file
            QDesktopServices.openUrl(QUrl.fromLocalFile("temp_image.png"))
        except Exception as e:
            QMessageBox.warning(self, "Error Opening PDF", f"Error opening PDF: {str(e)}")

    def open_word_in_browser(self, file_path):
        try:
            print("ASDASDASD")
            # Use python-docx2txt to extract text content from the Word document
            from docx2txt import process

            text_content = process(file_path)

            # Display the text content in a QWebEngineView
            browser_view = QWebEngineView()
            browser_view.setHtml(text_content)
            browser_view.showMaximized()

        except Exception as e:
            QMessageBox.warning(self, "Error Opening Word Document", f"Error opening Word document: {str(e)}")

    def open_image(self, file_path):
        # Open image files using Pillow
        progress_dialog = QProgressDialog("Opening...", None, 0, 0, self)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Call your login function in a separate thread or process
        # For simplicity, let's simulate a delay using QEventLoop
        loop = QEventLoop()
        QTimer.singleShot(2000, loop.quit)
        loop.exec_()

        # Close the progress dialog
        progress_dialog.close()
        print("pic")
        try:
            img = Image.open(file_path)
            img.show()
        except Exception as e:
            QMessageBox.warning(self, "Error Opening Image", f"Error opening image: {str(e)}")

    def handle_download_request(self, download_item):
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly

        # Specify the directory where you want to save downloaded files
        storage_dir = 'storage'

        # Check if the storage directory exists, and if not, create it
        if not os.path.exists(storage_dir):
            os.makedirs(storage_dir)

        suggested_name = download_item.suggestedFileName()

        save_path = os.path.join(storage_dir, suggested_name)

        if save_path:
            download_item.setPath(save_path)
            download_item.accept()

            # Store the file path in MongoDB along with self.ID
            self.store_download_info(self.ID, save_path)

            # Show a success message when the download is complete
            QMessageBox.information(self, "Download Success", f"Downloaded file saved to:\n{save_path}")

    def store_download_info(self, user_id, file_path):
        # Connect to MongoDB
        mongo_url = "mongodb+srv://otmanagement:otmanagement@otmanagement.prask0n.mongodb.net/"
        client = MongoClient(mongo_url)
        database = client['downloaded_fils']  # Replace 'your_database_name' with your actual database name
        collection = database['downloads']

        # Create a document with user_id and file_path
        download_info = {
            "user_id": user_id,
            "file_path": file_path
        }

        # Insert the document into the MongoDB collection
        result = collection.insert_one(download_info)

        # Print the autogenerated ID (optional)
        print(f"Download info stored - User ID: {user_id}, File Path: {file_path}, ID: {result.inserted_id}")

        # Close the MongoDB connection
        client.close()

    def file_to_base64(self, binary_data):
        try:
            base64_data = base64.b64encode(binary_data).decode("utf-8")
            return base64_data
        except Exception as e:
            return None

    def show_loading_bar(self):
        loading_dialog = LoadingDialog(self)
        loading_dialog.show()

        # Create a worker thread for the time-consuming task
        self.worker = Worker()
        self.worker.progress_changed.connect(loading_dialog.set_progress)
        self.worker.label_changed.connect(loading_dialog.set_progress_label)
        self.worker.finished.connect(loading_dialog.close)

        # Start the worker thread
        self.worker.start()


def main():
    app = QApplication(sys.argv)
    QFontDatabase.addApplicationFont("path_to_font_file.ttf")
    window = WebBrowser()
    window.setWindowTitle("K2332916 Web Browser")
    window.setGeometry(100, 100, 1024, 768)
    window.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()

# python -m PyInstaller --onefile web_browser.py   to bild exe file

# import base64
# import os
# import sys
# from PyQt5.QtCore import QUrl
# from PyQt5.QtGui import QFontDatabase, QDesktopServices  # Import QFontDatabase
# from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEnginePage
# from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QToolBar, QLineEdit, QStatusBar, QMessageBox, \
#     QFileDialog, QListWidget, QDialog, QVBoxLayout, QListWidgetItem, QAbstractItemView
#
#
# class WebBrowser(QMainWindow):
#     def __init__(self):
#         super().__init__()
#         self.browser = QWebEngineView()
#         self.browser.setUrl(QUrl("https://www.google.com"))
#         self.setCentralWidget(self.browser)
#
#         nav_toolbar = QToolBar("Navigation")
#         self.addToolBar(nav_toolbar)
#
#         back_btn = QAction("Back", self)
#         back_btn.setStatusTip("Back to the previous page")
#         back_btn.triggered.connect(self.browser.back)
#         nav_toolbar.addAction(back_btn)
#
#         forward_btn = QAction("Forward", self)
#         forward_btn.setStatusTip("Forward to the next page")
#         forward_btn.triggered.connect(self.browser.forward)
#         nav_toolbar.addAction(forward_btn)
#
#         reload_btn = QAction("Reload", self)
#         reload_btn.setStatusTip("Reload page")
#         reload_btn.triggered.connect(self.browser.reload)
#         nav_toolbar.addAction(reload_btn)
#
#         home_btn = QAction("Home", self)
#         home_btn.setStatusTip("Go to the home page")
#         home_btn.triggered.connect(self.navigate_home)
#         nav_toolbar.addAction(home_btn)
#
#         nav_toolbar.addSeparator()
#
#         self.urlbar = QLineEdit()
#         self.urlbar.returnPressed.connect(self.navigate_to_url)
#         nav_toolbar.addWidget(self.urlbar)
#
#         stop_btn = QAction("Stop", self)
#         stop_btn.setStatusTip("Stop loading the current page")
#         stop_btn.triggered.connect(self.browser.stop)
#         nav_toolbar.addAction(stop_btn)
#
#         # Add a "View Downloads" button to the navigation toolbar
#         view_downloads_btn = QAction("View Downloads", self)
#         view_downloads_btn.setStatusTip("View downloaded files")
#         view_downloads_btn.triggered.connect(self.view_downloads)
#         nav_toolbar.addAction(view_downloads_btn)
#
#         self.downloads_list = QListWidget()  # Create a list widget to display downloaded files
#         self.downloads_list.setSelectionMode(QAbstractItemView.SingleSelection)
#         self.downloads_list.itemDoubleClicked.connect(self.open_selected_download)
#
#         self.downloads_list = QListWidget()  # Create a list widget to display downloaded files
#
#         self.browser.urlChanged.connect(self.update_urlbar)
#         self.status = QStatusBar()
#         self.setStatusBar(self.status)
#
#         # Connect the loadFinished signal to show an alert when the page is loaded.
#         self.browser.loadFinished.connect(self.page_loaded_alert)
#
#         # Create a QWebEnginePage instance for handling downloads
#         self.download_page = QWebEnginePage(self)
#         self.download_page.profile().downloadRequested.connect(self.handle_download_request)
#
#     def navigate_home(self):
#         self.browser.setUrl(QUrl("https://www.google.com"))
#
#     def navigate_to_url(self):
#         q = QUrl(self.urlbar.text())
#         if q.scheme() == "":
#             q.setScheme("http")
#         self.browser.setUrl(q)
#
#     def update_urlbar(self, q):
#         self.urlbar.setText(q.toString())
#         self.urlbar.setCursorPosition(0)
#
#     def page_loaded_alert(self, ok):
#         if ok:
#             QMessageBox.information(self, "Page Loaded", "The page has finished loading.")
#
#     def view_downloads(self):
#         print("HEllo")
#         # Create a dialog to display downloaded files
#         dialog = QDialog(self)
#         dialog.setWindowTitle("Downloads")
#
#         layout = QVBoxLayout()
#         layout.addWidget(self.downloads_list)
#         dialog.setLayout(layout)
#
#         # Populate the downloads list with downloaded files
#         storage_dir = 'storage'
#         if os.path.exists(storage_dir):
#             downloaded_files = os.listdir(storage_dir)
#             for file_name in downloaded_files:
#                 item = QListWidgetItem(file_name)
#                 self.downloads_list.addItem(item)
#
#         dialog.exec_()
#
#     def open_selected_download(self):
#         selected_item = self.downloads_list.currentItem()
#         if selected_item:
#             file_name = selected_item.text()
#             storage_dir = 'storage'
#             file_path = os.path.join(storage_dir, file_name)
#
#             if os.path.exists(file_path):
#                 # Use QDesktopServices to open the file with the default application
#                 if QDesktopServices.openUrl(QUrl.fromLocalFile(file_path)):
#                     print(f"File opened successfully: {file_path}")
#                 else:
#                     print(f"Failed to open file: {file_path}")
#             else:
#                 print(f"File does not exist: {file_path}")
#
#     def handle_download_request(self, download_item):
#         options = QFileDialog.Options()
#         options |= QFileDialog.ReadOnly
#
#         # Specify the directory where you want to save downloaded files
#         storage_dir = 'storage'
#
#         # Check if the storage directory exists, and if not, create it
#         if not os.path.exists(storage_dir):
#             os.makedirs(storage_dir)
#
#         # Get the suggested file name from the download item
#         suggested_name = download_item.suggestedFileName()
#
#         # Construct the full path to save the file in the storage directory
#         save_path = os.path.join(storage_dir, suggested_name)
#
#         # Show a file dialog for choosing the download location (optional)
#         # save_path, _ = QFileDialog.getSaveFileName(self, "Save File", save_path, options=options)
#
#         if save_path:
#             download_item.setPath(save_path)
#             download_item.accept()
#
#             # Show a success message when the download is complete
#             QMessageBox.information(self, "Download Success", f"Downloaded file saved to:\n{save_path}")
#
#     def file_to_base64(self, binary_data):
#         try:
#             base64_data = base64.b64encode(binary_data).decode("utf-8")
#             return base64_data
#         except Exception as e:
#             return None
# def main():
#     app = QApplication(sys.argv)
#     QFontDatabase.addApplicationFont("path_to_font_file.ttf")  # Replace with the actual path to the font file
#     window = WebBrowser()
#     window.setWindowTitle("Python Web Browser")
#     window.setGeometry(100, 100, 1024, 768)
#     window.show()
#     sys.exit(app.exec_())
#
# if __name__ == "__main__":
#     main()
